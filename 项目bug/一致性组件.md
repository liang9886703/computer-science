# 租约到期，kv没有删除

kv和租约没有导通，实现导通

kv中用map记录key和租约的关系

- **protobuf类型的数据没有调用初始化函数就赋值，在通过网络发送时会不通过安全检查，**

R:要调用protobuf的初始化函数

- **两次free**

R：用vector接收租约数据传递给出参，租约数据里的部分数据是浅拷贝，vector析构调用租约析构释放掉了，出参发送网络后再释放掉，造成两次释放

S：深拷贝

- **读出原本认为删除的值**

R：对于自定义数据类型，加入map的方式不对，比较重载函数不对，

S: 对于每次用key查询和用key赋值都要深拷贝一个key再用于查询，重载函数的返回值应该用布尔类型，对于int类型会不确定产生的结果

```cpp
struct Key1
{
    Key1() : size(0), data(NULL) {}
    Key1(size_t size, std::uint8_t* data) : size(size), data(data) {}
    size_t size;
    const std::uint8_t* data;

    bool operator()(const Key1& L, const Key1& R) const {
        if (L.data == NULL) {
            return false;
        }
        else if (R.data == NULL) {
            return true;
        }
        else if (L.data == R.data && L.size == R.size) {
            return true;
        }
        else if (L.size == R.size) {
            return memcmp(L.data, R.data, R.size)> 0 ? true : false;
        }
        else {
            int res = memcmp(L.data, R.data, L.size < R.size ? L.size : R.size);
            return  res == 0 ? (L.size < R.size ? false : true) : (res > 0 ? true : false);
        }
     }
};

Key1 copy_key(Key1 L) {
    std::uint8_t* t = (std::uint8_t*)malloc(L.size);
    memcpy(t, L.data, L.size);
    Key1 R = { L.size, t };
    return R;
}
int main()
{
    map<Key1, int, Key1> ma;

    std::uint8_t* d1 = (std::uint8_t*)"k1d1";
    std::uint8_t* d2 = (std::uint8_t*)"k2d2";

    Key1 kv1 = { 4, d1 };
    Key1 kv2 = { 4, d2 };
    Key1 kv11 = copy_key(kv1);
    Key1 kv22 = copy_key(kv2);
    ma[kv1] = 1;
    ma[kv2] = 2;

    printf("er\n");
    printf("kv  %d\n", ma[kv22]);
```

- 整体测试能过，单元测试不能过

写代码没有考虑单元测试，默认外层做的初始化

- 子类没有重写父类的纯虚函数

  子类是新建的文件，重新cmake

- 静态变量成员没有定义，用的第三方库的

  cmake连接这个库，静态成员需要做初始化

- 在类静态函数中用智能指针获取传入值时，析构函数是私有变量

```cpp
stu{
  static void test(void*p){
      auto a = static_cast<stu*>p;
      //不能用智能指针接收，用智能指针这里就只有一个引用，test一结束就会释放空间
      //std::shared_ptr<stu> p(static_cast<stu*>(ptr))//error
      //而原本上，是不希望释放这个p的
      //也不能将void*转为智能指针使用，因为不存在这样的转换
  }  
}

```

