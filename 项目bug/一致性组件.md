# 租约到期，kv没有删除

kv和租约没有导通，实现导通

kv中用map记录key和租约的关系

- **protobuf类型的数据没有调用初始化函数就赋值，在通过网络发送时会不通过安全检查，**

R:要调用protobuf的初始化函数

- **两次free**

R：用vector接收租约数据传递给出参，租约数据里的部分数据是浅拷贝，vector析构调用租约析构释放掉了，出参发送网络后再释放掉，造成两次释放

S：深拷贝

- **读出原本认为删除的值**

R：对于自定义数据类型，加入map的方式不对，比较重载函数不对，

S: 对于每次用key查询和用key赋值都要深拷贝一个key再用于查询，重载函数的返回值应该用布尔类型，对于int类型会不确定产生的结果

```cpp
struct Key1
{
    Key1() : size(0), data(NULL) {}
    Key1(size_t size, std::uint8_t* data) : size(size), data(data) {}
    size_t size;
    const std::uint8_t* data;

    bool operator()(const Key1& L, const Key1& R) const {
        if (L.data == NULL) {
            return false;
        }
        else if (R.data == NULL) {
            return true;
        }
        else if (L.data == R.data && L.size == R.size) {
            return true;
        }
        else if (L.size == R.size) {
            return memcmp(L.data, R.data, R.size)> 0 ? true : false;
        }
        else {
            int res = memcmp(L.data, R.data, L.size < R.size ? L.size : R.size);
            return  res == 0 ? (L.size < R.size ? false : true) : (res > 0 ? true : false);
        }
     }
};

Key1 copy_key(Key1 L) {
    std::uint8_t* t = (std::uint8_t*)malloc(L.size);
    memcpy(t, L.data, L.size);
    Key1 R = { L.size, t };
    return R;
}
int main()
{
    map<Key1, int, Key1> ma;

    std::uint8_t* d1 = (std::uint8_t*)"k1d1";
    std::uint8_t* d2 = (std::uint8_t*)"k2d2";

    Key1 kv1 = { 4, d1 };
    Key1 kv2 = { 4, d2 };
    Key1 kv11 = copy_key(kv1);
    Key1 kv22 = copy_key(kv2);
    ma[kv1] = 1;
    ma[kv2] = 2;

    printf("er\n");
    printf("kv  %d\n", ma[kv22]);
```

- 整体测试能过，单元测试不能过

写代码没有考虑单元测试，默认外层做的初始化
